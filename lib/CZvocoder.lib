
//res= 0.5 to 64. this is multiplied by the fundamental pitch
//CZrestrap(fund, res) =
//-----------------------------------------------
// CZ vocoder synthesis
//-----------------------------------------------

//czCenters=     par(i,nrBands,   pow((pow((czTop/czBottom),1/15)),i)*czBottom);
czFund(freq,phase) =
    // (fund(freq,czOctave)+phase)-
    // ((fund(freq,czOctave)+phase):floor);
    (fund(freq,czOctave)+phase):decimal;

czFunds(freq,i) =
  (czNoises(i,freq,enableFOFnoiseFilter)):par(j, nrBands, czFund(freq));

czCenters = VocoderFreqsChooser(czBottom,czMid,czBand,czTop,para):dezipBands;
czPhases = VocoderLinArrayChooser(czPhaseBottom,czPhaseMid,czPhaseBand,czPhaseTop,para):dezipBands;
czPhaseRands = VocoderLinArrayChooser(czPhaseRandBottom,czPhaseRandMid,czPhaseRandBand,czPhaseRandTop,para):dezipBands;
czNoiseFilterFreqs = VocoderFreqsChooser(czNoiseFilterBottom,czNoiseFilterMid,czNoiseFilterBand,czNoiseFilterTop,para):dezipBands;

czOscs=
    interleave(nrBands,2):
    par(i, nrBands, CZrestrap);

//normal mixer without outputRouting
// CZvocoderMixer(0,0) = bus(nrBands*nrOutChan):>bus(nrOutChan);
CZvocoderMixer(0,0) = par(i,nrOutChan, bus(nrBands):>_);

//normal mixer with outputRouting
CZvocoderMixer(0,1) =bus(nrBands*nrOutChan)<:(
                (par(i,nrOutChan, bus(nrBands):>((xfadeSelector(outputRouting,0):dezip) *_)))
               ,(bus(nrBands*nrOutChan):>(par(i,nrOutChan, (xfadeSelector(outputRouting,1):dezip)*_)))
               ,(par(i,nrOutChan, bus(nrBands):>((xfadeSelector(outputRouting,2):dezip)) *_):butterfly(nrOutChan))
               ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(bus(nrBands):>_*((xfadeSelector(outputRouting,3):dezip)))))
               ,(bus(nrBands*nrOutChan):>butterfly(nrOutChan):par(i,nrOutChan,((xfadeSelector(outputRouting,4):dezip)) *_):cross(nrOutChan))
               ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(butterfly(nrBands):>_*((xfadeSelector(outputRouting,5):dezip)))))
               ,(butterfly(nrBands*nrOutChan):>(par(i,nrOutChan,((xfadeSelector(outputRouting,6):dezip) *_))))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrOutChan);

// Ambisonics mixer.

CZvocoderMixer(1, outputRoutingEnabled)  = routing(outputRoutingEnabled):((angles,bus(nrBands*nrOutChan)): interleave(nrBands*nrOutChan,2)) : par(i,nrBands*nrOutChan,myMap):>bus((ambisonicsOrder*2)+1)
with {
  myMap(a) = _<:encoder(ambisonicsOrder, _, a);
  angles = par(i,nrBands*nrOutChan/2,   ((angleTop-angleBottom)*(i/(nrBands*nrOutChan/2)))+angleBottom)<:(bus(nrBands),par(i,nrBands,_*-1)):interleave(nrBands,2);
  routing(0) = bus(nrBands*nrOutChan);
  routing(1) =bus(nrBands*nrOutChan)<:(
               (bus(nrBands*nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,0):dezip) *_)))
               ,(interleave(nrBands,nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,1):dezip) *_)))
               ,(butterfly(nrBands*nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,2):dezip) *_)))
               ,(butterfly(nrBands*nrOutChan):interleave(nrBands,nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,3):dezip) *_)))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrBands*nrOutChan);
};

// czNoises(polarity,freq,enableCZnoiseFilter) =
//TODO: make true multichannel version
czNoises(i,freq,0) = (czPhases,(czPhaseRands:par(j,nrBands,(_*(noise):smooth(tau2pole(czPhaseSpeed))))):>(par(j, nrBands,_*select2(i%2,1,-1))));
czNoises(i,freq,1) =(czPhases,((czPhaseRands:par(j,nrBands,(_*(noise):lowpass(1,(czNoiseFilterFreqs:selector(j,nrBands)*(freq*czOctave*0.000001))))))):>(par(j, nrBands,_*select2(i%2,1,-1))));

// czVocoder(audio,freq,doubleOscs)
czVocoder(audio,freq,0)=
  //the noises part is to make a different (low)freq modulation for each osc.
  //noises(nrBands,0):smooth(tau2pole(32))
  //"(i+1)*" is to make each band different
  (czFunds(freq,0),czCenters)
  :czOscs
  :gainNormalise
  :((analizer(voice(audio),freq,enableDeEsser),par(i, nrBands, _)):interleave(nrBands,2):par(i, nrBands,*))
  :vocoderMixer(ambisonicsOn,outputRoutingEnabled)
  :postProc(nrOutChan,ambisonicsOn,enableAutosat,volume*0.1,1);

czVocoder(audio,freq,1)=
  //the noises part is to make a different (low)freq modulation for each osc.
  //noises(nrBands,0):smooth(tau2pole(32))
  //"(i+1)*" is to make each band different
  par(i,nrOutChan,
    (czFunds(freq,i),czCenters)
    : czOscs
    : gainNormalise
    :((analizer(voice(audio),freq,enableDeEsser),par(i, nrBands, _)):interleave(nrBands,2):par(i, nrBands,*))
  )
  :CZvocoderMixer(ambisonicsOn,outputRoutingEnabled)
  :postProc(nrOutChan,ambisonicsOn,enableAutosat,volume*0.1,1);
