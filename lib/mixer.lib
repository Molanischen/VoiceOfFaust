//Make a mixer with nrOutChan inputs and nrSends outputs per input

declare name 		"Mixer";
declare version 	"0.2";
declare author 		"Bart Brouns";
declare license 	"GNU 3.0";
declare copyright 	"(c) Bart Brouns 2014";


//-----------------------------------------------
// mixerWithSends
//-----------------------------------------------

// mixerWithSends(nrChan,nrOutChan,nrSends)

// A mixer with nrChan inputs, each nrOutChan wide, and having nrSends aux sends


//make a channel with nrSends outputs.
//The inputs are: volumes,audio
monoChannel(nrSends) = (bus(nrSends),(_<:bus(nrSends))):badInterleave(nrSends,2):par(o,nrSends,_*_);


//make a bus with nrOutChan channels, each having nrSends sends
//inputs: nrSends volumes followed by nrOutChan audio inputs
//outputs: lr,lr,lr
busWithSends(nrOutChan,nrSends)= bus(nrOutChan+nrSends)<:par(i,nrOutChan,sel(nrOutChan,nrSends,i)):par(i,nrOutChan,monoChannel(nrSends)):badInterleave(nrSends,nrOutChan)
with {
sel(nrOutChan,nrSends,i) = (par(i,nrSends,_),par(i,nrOutChan,!),(selector(i+nrSends,nrOutChan+nrSends)));
};




//inputs: nrChan paralel versions of:
//nrSends volumes followed by nrOutChan audio inputs
//outputs: l,r, l,r, l,r

//for example:
//send1levelChan1,send2levelChan1,send3levelChan1,
//Chan1L.Chan1R,
//send1levelChan2,send2levelChan2,send3levelChan2,
//Chan2L.Chan2R,
//send1levelChan3,send2levelChan3,send3levelChan3,
//Chan3L.Chan3R:
//send1levelChan4,send2levelChan4,send3levelChan4,
//Chan4L.Chan4R:
//mixerWithSends(4,2,3)
//will produce:
//send1L,send1R.send2L.send2R,send3L.send3R,
//carefull; no send4L or send4R will be created, as 4 is the number of inputchannels, not the nr of sends
mixerWithSends(nrChan,nrOutChan,nrSends) =
par(i,nrChan,busWithSends(nrOutChan,nrSends)):badInterleave(nrSends*nrOutChan,nrChan):mix
with {
mix=par(i,nrOutChan*nrSends,(bus(nrChan):>_));
};


//-----------------------------------------------
// vocoderMixer
//-----------------------------------------------

// various ways to mix the bands of a vocoder to a certain number of output-channels
// so  bus(nrBands) to bus(nrOutChan)

// vocoderMixer(audio,freq,ambisonicsOn,outputRoutingEnabled,doubleOscs)
//normal mixer without outputRouting
vocoderMixer(audio,freq,0,0,0) = reEsser(audio,freq,0,enableReEsser) :>bus(nrOutChan);

//normal mixer with outputRouting
vocoderMixer(audio,freq,0,1,0) = reEsser(audio,freq,0,enableReEsser) <:(
                (par(i,nrOutChan, bus(nrBands/nrOutChan):>((xfadeSelector(outputRouting,0):dezip) *_)))
               ,(bus(nrBands):>(par(i,nrOutChan, (xfadeSelector(outputRouting,1):dezip)*_)))
               ,(par(i,nrOutChan, bus(nrBands/nrOutChan):>((xfadeSelector(outputRouting,2):dezip)) *_):butterfly(nrOutChan))
               ,(badInterleave(nrBands/nrOutChan,nrOutChan):par(i, nrOutChan,(bus(nrBands/nrOutChan):>_*((xfadeSelector(outputRouting,3):dezip)))))
               ,(bus(nrBands):>butterfly(nrOutChan):par(i,nrOutChan,((xfadeSelector(outputRouting,4):dezip)) *_):cross(nrOutChan))
               ,(badInterleave(nrBands/nrOutChan,nrOutChan):par(i, nrOutChan,(butterfly(nrBands/nrOutChan):>_*((xfadeSelector(outputRouting,5):dezip)))))
               ,(butterfly(nrBands):>(par(i,nrOutChan,((xfadeSelector(outputRouting,6):dezip) *_))))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrOutChan);

// Ambisonics mixer.
vocoderMixer(audio,freq,1, outputRoutingEnabled,0)  =
  reEsser(audio,freq,0,enableReEsser)
  :routing(outputRoutingEnabled)
  :((angles,bus(nrBands)): badInterleave(nrBands,2))
  : par(i,nrBands,myMap):>bus((ambisonicsOrder*2)+1)
with {
  myMap(a) = _<:encoder(ambisonicsOrder, _, a);
  angles = par(i,nrBands/2,   ((angleTop-angleBottom)*(i/(nrBands/2)))+angleBottom)<:(bus(nrBands/2),par(i,nrBands/2,_*-1)):badInterleave(nrBands/2,2);
  routing(0) = bus(nrBands);
  routing(1) =bus(nrBands)<:(
               (bus(nrBands):(par(i,nrBands,(xfadeSelector(outputRouting,0):dezip) *_)))
               ,(badInterleave(nrBands/nrOutChan,nrOutChan):(par(i,nrBands,(xfadeSelector(outputRouting,1):dezip) *_)))
               ,(butterfly(nrBands):(par(i,nrBands,(xfadeSelector(outputRouting,2):dezip) *_)))
               ,(butterfly(nrBands):badInterleave(nrBands/nrOutChan,nrOutChan):(par(i,nrBands,(xfadeSelector(outputRouting,3):dezip) *_)))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrBands);
};


//normal mixer without outputRouting, doubleOscs
vocoderMixer(audio,freq,0,0,1) = reEsser(audio,freq,1,enableReEsser) : par(i,nrOutChan, bus(nrBands):>_);

//normal mixer with outputRouting, doubleOscs
vocoderMixer(audio,freq,0,1,1) = reEsser(audio,freq,1,enableReEsser) <:(
                (par(i,nrOutChan, bus(nrBands):>((xfadeSelector(outputRouting,0):dezip) *_)))
               ,(bus(nrBands*nrOutChan):>(par(i,nrOutChan, (xfadeSelector(outputRouting,1):dezip)*_)))
               ,(par(i,nrOutChan, bus(nrBands):>((xfadeSelector(outputRouting,2):dezip)) *_):butterfly(nrOutChan))
               ,(badInterleave(nrBands,nrOutChan):par(i, nrOutChan,(bus(nrBands):>_*((xfadeSelector(outputRouting,3):dezip)))))
               ,(bus(nrBands*nrOutChan):>butterfly(nrOutChan):par(i,nrOutChan,((xfadeSelector(outputRouting,4):dezip)) *_):cross(nrOutChan))
               ,(badInterleave(nrBands,nrOutChan):par(i, nrOutChan,(butterfly(nrBands):>_*((xfadeSelector(outputRouting,5):dezip)))))
               ,(butterfly(nrBands*nrOutChan):>(par(i,nrOutChan,((xfadeSelector(outputRouting,6):dezip) *_))))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrOutChan);

// Ambisonics mixer, doubleOscs
vocoderMixer(audio,freq,1, outputRoutingEnabled,1)  =
  reEsser(audio,freq,1,enableReEsser)
  :routing(outputRoutingEnabled)
  :((angles,bus(nrBands*nrOutChan)) : badInterleave(nrBands*nrOutChan,2))
  : par(i,nrBands*nrOutChan,myMap):>bus((ambisonicsOrder*2)+1)
with {
  myMap(a) = _<:encoder(ambisonicsOrder, _, a);
  angles = par(i,nrBands*nrOutChan/2,   ((angleTop-angleBottom)*(i/(nrBands*nrOutChan/2)))+angleBottom)<:(bus(nrBands),par(i,nrBands,_*-1)):badInterleave(nrBands,2);
  routing(0) = bus(nrBands*nrOutChan);
  routing(1) =bus(nrBands*nrOutChan)<:(
               (bus(nrBands*nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,0):dezip) *_)))
               ,(badInterleave(nrBands,nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,1):dezip) *_)))
               ,(butterfly(nrBands*nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,2):dezip) *_)))
               ,(butterfly(nrBands*nrOutChan):badInterleave(nrBands,nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,3):dezip) *_)))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrBands*nrOutChan);
};
