
//-----------------------------------------------
// FOF vocoder synthesis
//-----------------------------------------------

//fofCenters=     par(i,nrBands,   pow((pow((fofTop/fofBottom),1/15)),i)*fofBottom);
fofFund(freq) =
    fund(freq,fofOctave);

fofCenters = VocoderFreqsChooser(fofBottom,fofMid,fofBand,fofTop,para):dezipBands;
/*fofSkirts  = VocoderFreqs(fofSkirtBottom,fofSkirtTop);*/
/*fofDecays  = VocoderFreqs(fofDecayBottom,fofDecayTop);*/
fofSkirts  = VocoderFreqsChooser(fofSkirtBottom,fofSkirtMid,fofSkirtBand,fofSkirtTop,para):dezipBands;
fofDecays  = VocoderLinArrayChooser(fofDecayBottom,fofDecayMid,fofDecayBand,fofDecayTop,para):dezipBands;
fofPhases = VocoderLinArrayChooser(fofPhaseBottom,fofPhaseMid,fofPhaseBand,fofPhaseTop,para):dezipBands;
fofOctavations = VocoderLinArrayChooser(fofOctavationBottom,fofOctavationMid,fofOctavationBand,fofOctavationTop,para):dezipBands;

fofOscs=
    interleave(nrBands,6):
    par(i, nrBands, (fof));
//fof(fReso,fund,skirt,decay,phase,vol) =

//normal mixer
// FOFvocoderMixer(0) =bus(nrBands*nrOutChan)<:(
//                (bus(nrBands*nrOutChan):>(par(i,nrOutChan,(outputRouting==0:dezip) *_)))
//                ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(bus((nrBands)):>_*(outputRouting==1:dezip))))
//                ,(par(i,nrOutChan, bus(nrBands):>(outputRouting==2:dezip) *_))
//                ,(butterfly(nrBands*nrOutChan):>(par(i,nrOutChan,(outputRouting==3:dezip) *_)))
//                ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(butterfly((nrBands)):>_*(outputRouting==4:dezip))))
//                ,(bus(nrBands*nrOutChan):>butterfly(nrOutChan):par(i,nrOutChan,(outputRouting==5:dezip) *_))
//                ,(par(i,nrOutChan, bus(nrBands):>(outputRouting==6:dezip) *_):butterfly(nrOutChan))
//                /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
//              ):>bus(nrOutChan);

//normal mixer without outputRouting
// FOFvocoderMixer(0,0) = bus(nrBands*nrOutChan):>bus(nrOutChan);
// FOFvocoderMixer(0,0) = par(i,nrOutChan, bus(nrBands):>_);

// //normal mixer with outputRouting
// FOFvocoderMixer(0,1) =bus(nrBands*nrOutChan)<:(
//                 (par(i,nrOutChan, bus(nrBands):>((xfadeSelector(outputRouting,0):dezip) *_)))
//                ,(bus(nrBands*nrOutChan):>(par(i,nrOutChan, (xfadeSelector(outputRouting,1):dezip)*_)))
//                ,(par(i,nrOutChan, bus(nrBands):>((xfadeSelector(outputRouting,2):dezip)) *_):butterfly(nrOutChan))
//                ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(bus(nrBands):>_*((xfadeSelector(outputRouting,3):dezip)))))
//                ,(bus(nrBands*nrOutChan):>butterfly(nrOutChan):par(i,nrOutChan,((xfadeSelector(outputRouting,4):dezip)) *_):cross(nrOutChan))
//                ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(butterfly(nrBands):>_*((xfadeSelector(outputRouting,5):dezip)))))
//                ,(butterfly(nrBands*nrOutChan):>(par(i,nrOutChan,((xfadeSelector(outputRouting,6):dezip) *_))))
//                /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
//              ):>bus(nrOutChan);

// // Ambisonics mixer.

// FOFvocoderMixer(1, outputRoutingEnabled)  = routing(outputRoutingEnabled):((angles,bus(nrBands*nrOutChan)): interleave(nrBands*nrOutChan,2)) : par(i,nrBands*nrOutChan,myMap):>bus((ambisonicsOrder*2)+1)
// with {
//   myMap(a) = _<:encoder(ambisonicsOrder, _, a);
//   angles = par(i,nrBands*nrOutChan/2,   ((angleTop-angleBottom)*(i/(nrBands*nrOutChan/2)))+angleBottom)<:(bus(nrBands),par(i,nrBands,_*-1)):interleave(nrBands,2);
//   routing(0) = bus(nrBands*nrOutChan);
//   routing(1) =bus(nrBands*nrOutChan)<:(
//                (bus(nrBands*nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,0):dezip) *_)))
//                ,(interleave(nrBands,nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,1):dezip) *_)))
//                ,(butterfly(nrBands*nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,2):dezip) *_)))
//                ,(butterfly(nrBands*nrOutChan):interleave(nrBands,nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,3):dezip) *_)))
//                /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
//              ):>bus(nrBands*nrOutChan);
// };


// fofvocoder(audio,freq,doubleOscs)
fofvocoder(audio,freq,0)=
  //the noises part is to make a different (low)freq modulation for each osc.
  //noises(nrBands,0):smooth(tau2pole(32))
  //"(i+1)*" is to make each band different
  (fofNoises(0,freq,enableFOFnoise,enablePhaseNoiseFilter),fofCenters,(multiK(multi)<:bus(nrBands)),fofSkirts,fofDecays,fofOctavations)
  :fofOscs
  :gainNormalise
  :((analizer(voice(audio,index),freq,fidelity,enableDeEsser),par(i, nrBands, _)):interleave(nrBands,2):par(i, nrBands,*))
  :vocoderMixer(ambisonicsOn,outputRoutingEnabled,doubleOscs)
  :postProc(nrOutChan,ambisonicsOn,enableAutosat,volume*0.1,1);

fofvocoder(audio,freq,1)=
  //the noises part is to make a different (low)freq modulation for each osc.
  //noises(nrBands,0):smooth(tau2pole(32))
  //"(i+1)*" is to make each band different
  par(i,nrOutChan
    ,(fofNoises(i,freq,enableFOFnoise,enablePhaseNoiseFilter),fofCenters,(multiK(multi)<:bus(nrBands)),fofSkirts,fofDecays,fofOctavations)
    :fofOscs
    : gainNormalise
    :((analizer(voice(audio,index),freq,fidelity,enableDeEsser),par(i, nrBands, _)):interleave(nrBands,2):par(i, nrBands,*))
  )
  :vocoderMixer(ambisonicsOn,outputRoutingEnabled,doubleOscs)
  :postProc(nrOutChan,ambisonicsOn,enableAutosat,volume*0.1,1);
