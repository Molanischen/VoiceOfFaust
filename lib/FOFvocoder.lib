
//-----------------------------------------------
// FOF vocoder synthesis
//-----------------------------------------------

//fofCenters=     par(i,nrBands,   pow((pow((fofTop/fofBottom),1/15)),i)*fofBottom);
fofFund(freq) =
    fund(freq,fofOctave);

fofCenters = VocoderFreqsChooser(fofBottom,fofMid,fofBand,fofTop,para);
/*fofSkirts  = VocoderFreqs(fofSkirtBottom,fofSkirtTop);*/
/*fofDecays  = VocoderFreqs(fofDecayBottom,fofDecayTop);*/
fofSkirts  = VocoderFreqsChooser(fofSkirtBottom,fofSkirtMid,fofSkirtBand,fofSkirtTop,para);
fofDecays  = VocoderLinArrayChooser(fofDecayBottom,fofDecayMid,fofDecayBand,fofDecayTop,para);
fofPhaseRands = VocoderLinArrayChooser(fofPhaseRandBottom,fofPhaseRandMid,fofPhaseRandBand,fofPhaseRandTop,para);
fofPhases = VocoderLinArrayChooser(fofPhaseBottom,fofPhaseMid,fofPhaseBand,fofPhaseTop,para);

fofOscs=
    interleave(nrBands,6):
    par(i, nrBands, (fof));
//fof(fReso,fund,skirt,decay,phase,vol) =

//normal mixer
// FOFvocoderMixer(0) =bus(nrBands*nrOutChan)<:(
//                (bus(nrBands*nrOutChan):>(par(i,nrOutChan,(outputRouting==0:dezip) *_)))
//                ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(bus((nrBands)):>_*(outputRouting==1:dezip))))
//                ,(par(i,nrOutChan, bus(nrBands):>(outputRouting==2:dezip) *_))
//                ,(butterfly(nrBands*nrOutChan):>(par(i,nrOutChan,(outputRouting==3:dezip) *_)))
//                ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(butterfly((nrBands)):>_*(outputRouting==4:dezip))))
//                ,(bus(nrBands*nrOutChan):>butterfly(nrOutChan):par(i,nrOutChan,(outputRouting==5:dezip) *_))
//                ,(par(i,nrOutChan, bus(nrBands):>(outputRouting==6:dezip) *_):butterfly(nrOutChan))
//                /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
//              ):>bus(nrOutChan);

//normal mixer without outputRouting
// FOFvocoderMixer(0,0) = bus(nrBands*nrOutChan):>bus(nrOutChan);
FOFvocoderMixer(0,0) = par(i,nrOutChan, bus(nrBands):>_);

//normal mixer with outputRouting
FOFvocoderMixer(0,1) =bus(nrBands*nrOutChan)<:(
                (par(i,nrOutChan, bus(nrBands):>((xfadeSelector(outputRouting,0):dezip) *_)))
               ,(bus(nrBands*nrOutChan):>(par(i,nrOutChan, (xfadeSelector(outputRouting,1):dezip)*_)))
               ,(par(i,nrOutChan, bus(nrBands):>((xfadeSelector(outputRouting,2):dezip)) *_):butterfly(nrOutChan))
               ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(bus(nrBands):>_*((xfadeSelector(outputRouting,3):dezip)))))
               ,(bus(nrBands*nrOutChan):>butterfly(nrOutChan):par(i,nrOutChan,((xfadeSelector(outputRouting,4):dezip)) *_):cross(nrOutChan))
               ,(interleave(nrBands,nrOutChan):par(i, nrOutChan,(butterfly(nrBands):>_*((xfadeSelector(outputRouting,5):dezip)))))
               ,(butterfly(nrBands*nrOutChan):>(par(i,nrOutChan,((xfadeSelector(outputRouting,6):dezip) *_))))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrOutChan);

// Ambisonics mixer.

FOFvocoderMixer(1, outputRoutingEnabled)  = routing(outputRoutingEnabled):((angles,bus(nrBands*nrOutChan)): interleave(nrBands*nrOutChan,2)) : par(i,nrBands*nrOutChan,myMap):>bus((ambisonicsOrder*2)+1)
with {
  myMap(a) = _<:encoder(ambisonicsOrder, _, a);
  angles = par(i,nrBands*nrOutChan/2,   ((angleTop-angleBottom)*(i/(nrBands*nrOutChan/2)))+angleBottom)<:(bus(nrBands),par(i,nrBands,_*-1)):interleave(nrBands,2);
  routing(0) = bus(nrBands*nrOutChan);
  routing(1) =bus(nrBands*nrOutChan)<:(
               (bus(nrBands*nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,0):dezip) *_)))
               ,(interleave(nrBands,nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,1):dezip) *_)))
               ,(butterfly(nrBands*nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,2):dezip) *_)))
               ,(butterfly(nrBands*nrOutChan):interleave(nrBands,nrOutChan):(par(i,nrBands*nrOutChan,(xfadeSelector(outputRouting,3):dezip) *_)))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrBands*nrOutChan);
};

fofvocoder(audio,freq,0)=
  //the noises part is to make a different (low)freq modulation for each osc.
  //noises(nrBands,0):smooth(tau2pole(32))
  //"(i+1)*" is to make each band different
  (fofPhaseRands:par(j,nrBands,(_*(noise):smooth(tau2pole(fofPhaseSpeed)))),fofCenters,(fofFund(freq)<:bus(nrBands)),fofSkirts,fofDecays,par(i, nrBands, 1))
  :fofOscs
  :gainNormalise
  :((analizer(voice(audio),freq),par(i, nrBands, _)):interleave(nrBands,2):par(i, nrBands,*))
  :vocoderMixer(ambisonicsOn,outputRoutingEnabled)
  :postProc(nrOutChan,ambisonicsOn,volume*0.3,1);

fofvocoder(audio,freq,1)=
  //the noises part is to make a different (low)freq modulation for each osc.
  //noises(nrBands,0):smooth(tau2pole(32))
  //"(i+1)*" is to make each band different
  par(i,nrOutChan
    ,(((fofPhases,(fofPhaseRands:par(j,nrBands,(_*(noise):smooth(tau2pole(fofPhaseSpeed))))):>(par(j, nrBands,_*select2(i%2,1,-1))))),fofCenters,(fofFund(freq)<:bus(nrBands)),fofSkirts,fofDecays,par(i, nrBands, 1))
    :fofOscs: gainNormalise :((analizer(voice(audio),freq),par(i, nrBands, _)):interleave(nrBands,2):par(i, nrBands,*)))
  :FOFvocoderMixer(ambisonicsOn,outputRoutingEnabled)
  :postProc(nrOutChan,ambisonicsOn,volume*0.3,1);
