//-----------------------------------------------
// master index, all slave oscilators 'clock' to this.
//-----------------------------------------------
// simple sawtooth waveform oscillator between 0 and 1
// masterIndex(freq,index)= lf_sawpos(freq/4); // lowest possible pitch, as we can only shift up, using wrap
// defined in master.lib and slave.lib
fund(freq,index,oct)=             (4 * oct * masterIndex(freq,index)) : decimal; //choose octaves
fundPhase(freq,index,oct, phase)= (4 * oct * masterIndex(freq,index))+phase : decimal; //choose octaves and set phase

//-----------------------------------------------
// Some general functions
//-----------------------------------------------
// dezipper
dezip(x) = x:smooth(0.999);
dezipBands = par(i, nrBands, dezip);
// minimum of n values
minOfN(1) = _;
minOfN(2) = min;
minOfN(n) = (minOfN(n-1),_):min;
// maximum of n values
maxOfN(1) = _;
maxOfN(2) = max;
maxOfN(n) = (maxOfN(n-1),_):max;
// sum of n values
sumOfN(1) = _;
sumOfN(2) = +;
sumOfN(n) = (sumOfN(n-1),_):+;
// cheaper than actual dB calculations:
volScale=_:pow(2):smooth(0.999);
envelop                 = abs : max ~ -(1.0/SR) : max(db2linear(-70)) : linear2db;
VuMeter                 = par(i,2,_<:(_, (envelop :(OSCgroup(MeterGroup(hbargraph("[4][unit:dB][tooltip: output level in dB]", -70, +6))))):attach));

octaveMultiplier	=
    _<:
    (
        (_==-2) * 0.25,
        (_==-1) * 0.5,
        (_==0),
        (_==1) * 2,
        (_==2) * 4
    ):>_;

centers(freq,group) = group(VocoderFreqsChooser(bottom,mid,band,top,para)):par(i, nrBands, _*freq): dezipBands;

phases = VocoderLinArrayChooser(phaseBottom,phaseMid,phaseBand,phaseTop,para): dezipBands;

// phaseNoises(polarity,freq,enablePhasenoise,enablePhaseNoiseFilter,group) =
//TODO: make true multichannel version
// phaseNoises(i,freq,0,enablePhaseNoiseFilter,group) = group(phases:(par(j, nrBands,_*select2(i%2,1,-1))));
// phaseNoises(i,freq,1,0,group) = group(phases,(phaseNoiseAmounts:par(j,nrBands,(_*(noise):smooth(tau2pole(PhaseSpeed))))):>(par(j, nrBands,_*select2(i%2,1,-1))));
phaseNoises(i,freq,1,1,group) =(group(phases),((group(phaseNoiseAmounts):par(j,nrBands,(_*(noises(nrBands*nrOutChan,j*i)):LP(j))))):>(par(j, nrBands,_*select2(i%2,1,-1))))
with {
  LP(j) = seq(i, noisesFilterN, lowpass(1,(group(phaseNoiseFreqs)   :selector(j,nrBands)*(freq*0.025)))) ;
  // LP(j) = lowpass(noisesFilterN,(phaseNoiseFreqs   :selector(j,nrBands)*(freq*0.00000025)));
};

funds(freq,index,polarity,group) = par(i, nrBands, fundPhase(freq,index,group(octave),phase(i)) ) with {
  phase(i) = group(phases:selector(i,nrBands)*select2(polarity%2,1,-1));
};


phaseNoiseAmounts = VocoderLinArrayChooser(phaseNoiseAmountBottom,phaseNoiseAmountMid,phaseNoiseAmountBand,phaseNoiseAmountTop,para): dezipBands;
phaseNoiseFreqs    = VocoderFreqsChooser(phaseNoiseFreqBottom,phaseNoiseFreqMid,phaseNoiseFreqBand,phaseNoiseFreqTop,para): dezipBands;

      // make a log array of values, from bottom to top
LogArray(bottom,top,nrElements) =     par(i,nrElements,   pow((pow((top/bottom),1/(nrElements-1))),i)*bottom);


VocoderFreqsChooser(bottom,mid,band,top,0) = VocoderFreqs(bottom,top);
VocoderFreqsChooser(bottom,mid,band,top,1) = VocoderFreqsParametricMid(bottom,mid,band,top);

// Do the smoothing in the linear domain:
// Too expensive, not enough difference in the sound.
// VocoderFreqsChooser(bottom,mid,band,top,0) = VocoderFreqs(bottom,top): par(i, nrBands, hz2pianokey ): dezipBands : par(i, nrBands, pianokey2hz) ;
// VocoderFreqsChooser(bottom,mid,band,top,1) = VocoderFreqsParametricMid(bottom,mid,band,top): par(i, nrBands, hz2pianokey ): dezipBands : par(i, nrBands, pianokey2hz);

VocoderFreqs(bottom,top) = LogArray(bottom,top,nrBands);

VocoderFreqsParametricMid(bottom,mid,band,top) =
  (
    (
    (LogArray(midVal(1),top,nrBands):par(i,nrBands,_*(xfadeSelector(band,1))))
    ,((bottom,LogArray(midVal(2),top,nrBands-1)):par(i,nrBands,_*(xfadeSelector(band,2))))
    )
    ,par(j,nrBands-4,
        (
            (LogArray(bottom,midVal(midBand),midBand):(bus(midBand-1),!))
            ,LogArray(midVal(midBand),top,nrBands-midBand+1)
        ):par(i,nrBands,_*(xfadeSelector(band,midBand)))with {midBand=j+3;}
    )
    ,
    (
      ((LogArray(bottom,midVal(nrBands-1),nrBands-1),top):par(i,nrBands,_*(xfadeSelector(band,nrBands-1))))
      ,(LogArray(bottom,midVal(nrBands),nrBands):par(i,nrBands,_*(xfadeSelector(band,nrBands))))
    )
  )
  :>bus(nrBands)
  with {
  midVal(band)=
  ((mid>0)*((pow(((top/origMid(band))),mid)*origMid(band))))
  + ((mid<=0)*((pow(((bottom/origMid(band))),abs(mid))*origMid(band))));
  // todo: maybe dezip ?
  origMid(band) = (VocoderFreqs(bottom,top):selector(band-1,nrBands)):>_;
  };


      // make a lin array of values, from bottom to top
      //VocoderLinArray(bottom,top) =     par(i,nrBands,   ((top-bottom)*(i/(nrBands-1)))+bottom);

LinArray(bottom,top,0) =   0:! ;
LinArray(bottom,top,nrElements) =     par(i,nrElements,   ((top-bottom)*(i/(nrElements-1)))+bottom);

VocoderLinArrayChooser(bottom,mid,band,top,0) = VocoderLinArray(bottom,top);
VocoderLinArrayChooser(bottom,mid,band,top,1) = VocoderLinArrayParametricMid(bottom,mid,band,top);

VocoderLinArray(bottom,top) =     LinArray(bottom,top,nrBands);
      // doesn't compile:
/*VocoderLinArrayParametricMid(bottom,mid,band,top) = ArrayPart(floor(band+1)):par(i,nrBands,_*(xfadeSelector(band,floor(band+1))))*/
           /*with {*/
/*ArrayPart(1)         = LinArray(mid,top,nrBands);*/
/*ArrayPart(2)         = bottom,LinArray(mid,top,nrBands-1);*/
/*ArrayPart(midBand)         =*/
  /*(LinArray(bottom,mid,midBand):(bus(midBand-1),!))*/
  /*,LinArray(mid,top,nrBands-midBand+1);*/
           /*};*/
/*ArrayPart(nrBands-1) = LinArray(bottom,mid,nrBands-1),top;*/
/*ArrayPart(nrBands)   = LinArray(bottom,mid,nrBands);*/

VocoderLinArrayParametricMid(bottom,mid,band,top) =
(
  (
  (LinArray(mid,top,nrBands):par(i,nrBands,_*(xfadeSelector(band,1))))
  ,((bottom,LinArray(mid,top,nrBands-1)):par(i,nrBands,_*(xfadeSelector(band,2))))
  )
  ,par(j,nrBands-4,
      (
         (LinArray(bottom,mid,midBand):(bus(midBand-1),!))
         ,LinArray(mid,top,nrBands-midBand+1)
      ):par(i,nrBands,_*(xfadeSelector(band,midBand)))with {midBand=j+3;}
  )
  ,
  (
    ((LinArray(bottom,mid,nrBands-1),top):par(i,nrBands,_*(xfadeSelector(band,nrBands-1))))
    ,(LinArray(bottom,mid,nrBands):par(i,nrBands,_*(xfadeSelector(band,nrBands))))
  )
)
:>bus(nrBands);

bt=hslider("[0]bottom", 0, 0, 1, 0.001);
md=hslider("[1]mid", 0, 0, 1, 0.001);
bd=hslider("[2]band", nrBands/2, 1, nrBands, 0.001);
tp=hslider("[3]top", 0, 0, 1, 0.001);

  GRmeter_group(x)  = vgroup("[3] GR [tooltip: gain reduction in dB]", x);
    meter(nr)           = GRmeter_group(  _<:(_,(_:min(1):max(0):( (hbargraph("%nr", 0, 1))))):attach);

gainCompareElement(x,compGain) = (_<:(_,((_)*x)))~compare:(!,_) with {
  compare(gain,gainedX) =
    select2((gainCompEnable ),
      1,
        ((((gain:max(0.001):linear2db)+select2((gainedX:amp_follower_ud(0.002,0.004))>compGain,up,down)):min(maxGain):db2linear))
    );
  up = dbPs;
  down = dbPs*-2;
  maxGain = (compGain:max(0.001):linear2db) - (x:abs:max(0.001):linear2db);
  };

// gainCompare(audio,freq,fidelity,enableGainCompare)
gainCompare(audio,index,fidelity,freq,0) = bus(nrBands);
gainCompare(audio,index,fidelity,freq,1) = (bus(nrBands),analizer(voice(audio,freq),freq,fidelity,enableDeEsser)):interleave(nrBands,2):par(i,nrBands,gainCompareElement);
gainNormalise = (bus(nrBands),par(i, nrBands, 1)):interleave(nrBands,2):par(i,nrBands,gainCompareElement);

// scale the gain between 0 = all at avg, 1 = normal and 2 = expansion
// expansion means:
//   the loudest band stays the same
//   soft bands get softer

// gainScale(enableGainScale,scale,f)
gainScale(0,scale,f) = bus(nrBands);
gainScale(1,scale,f) = bus(nrBands)<:par(i, nrBands, gain(i))
with {
  gain(i) = par(i, nrBands, max(0.00000001):linear2db+freqWeighting(freq(i),weightingKind))<:
    (
       (xfadeSelector(scale,0)*(par(j, nrBands, _) : AvgVolume)+freqWeighting(freq(i),weightingKind)+  compresVolCompensate )
       // we use scale inside expander, so from scale=1 to 2 we don't want xfadeSelector
      ,(xfadeSelector(scale,1)*(scale<1)*selector(i,nrBands))
      ,((scale>=1)*expander(i))
    ):>_-freqWeighting(freq(i),weightingKind):db2linear;
  freq(i) = analizerCenters(f):selector(i,nrBands);
  expander(i) = bus(nrBands)<:
    (
      (scaledVolume(i) + MaxVolume) + expandVolCompensate
    ):>_;
  scaledVolume(i) =  bus(nrBands)<:( ((MaxVolume*-1)+selector(i,nrBands)) * (scale:pow(3)) );
  AvgVolume = sumOfN(nrBands)/nrBands;
  MaxVolume = maxOfN(nrBands);
  compresVolCompensate = (((scale:min(1)*-1)+1)*12);
  expandVolCompensate = ((scale-1):max(0)*8);
};

freqWeighting(f,weightingKind) =
// Atable(f);
// ITUtable(f);
  (
    (xfadeSelector(weightingKind,0)*-8),
    (xfadeSelector(weightingKind,1)*Atable(f)),
    (xfadeSelector(weightingKind,2)*ITUtable(f))
  ):>_;


// source: https://en.wikipedia.org/wiki/ITU-R_468_noise_weighting
// :<math>R_{ITU}(f) = \frac{1.246332637532143\cdot10^{-4} \, f}{\sqrt{(h_1(f))^2 + (h_2(f))^2}}</math>
// :<math>ITU(f) = 18.2+20\log_{10}\left(R_{ITU}(f)\right)</math>
// where
// :<math>h_1(f)=-4.737338981378384\cdot10^{-24} \, f^6 + 2.043828333606125\cdot10^{-15} \, f^4 - 1.363894795463638\cdot10^{-7} \, f^2 + 1</math>
// :<math>h_2(f)=1.306612257412824\cdot10^{-19} \, f^5  - 2.118150887518656\cdot10^{-11} \, f^3 + 5.559488023498642\cdot10^{-4} \, f</math>

// todo: values do not 100% match table from wikipedia:
// OK till 2000 Hz,
// peak at +-4500 Hz instead of 6300 Hz
// 2nd 0dB point at +- 7500 Hz instead of 12500 Hz
// 12500 Hz at -16dB instead  of 0dB
// 20000 Hz at -30dB instead of -22,2dB
ITUtable(f) = rdtable(int(SRmax/2)+1,ITUs,int(f:max(1):int(min(SRmax/2))));
// ITUtable(f) = rdtable(20000,ITU,int(f:max(20)));
ITUs = ITU(time);
ITU(f) = 18.2+linear2db(rITU(f));
rITU(f) = ( 1.246332637532143*(10:pow(-4))*f) / (sqrt( (h1(f):pow(2)) + (h2(f):pow(2)) ));
h1(f) =   (-4.737338981378384*(10:pow(-24))*(f:pow(6)))+(2.043828333606125*(10:pow(-15))*(f:pow(4)))-(1.363894795463638*(10:pow(-7))*(f:pow(2)))+1;
h2(f) =   ( 1.306612257412824*(10:pow(-19))*(f:pow(5)))+(2.118150887518656*(10:pow(-11))*(f:pow(3)))-(5.559488023498642*(10:pow(-4))*f);

myTable(f) = rdtable(int(SRmax/2)+1,my(time),int(f:max(1):int(min(SRmax/2))));
my(f) =
  (pow((pow((top/bottom),1/(nrElements-1))),(f:min(nrElements)))*bottom)
  with {
    top = 0;
    bottom = -144;//vslider("basscut", -100, -200, 0, 1);
    nrElements = 2000;
    top2 = 24;
    bottom2 = 0;
    nrElements2 = int(SRmax/2)-nrElements;
  };

// ===A===
// :<math>R_A(f)= {12200^2\cdot f^4\over (f^2+20.6^2)\quad\sqrt{(f^2+107.7^2)\,(f^2+737.9^2)}
// \quad (f^2+12200^2)}\ ,</math>
// :<math>A(f)=2.0+20\log_{10}\left(R_A(f)\right)</math>

rA(freq) = ((12200:pow(2)) * (f:pow(4))) / ( ((f:pow(2)) + (20.6:pow(2))) * sqrt(((f:pow(2)) + (107.7:pow(2))) * ((f:pow(2)) + (737.9:pow(2)))) * ((f:pow(2)) + (12200:pow(2))))
  with { f = (freq:max(20)(min(SRmax/4))); };
A(f) = 2 + linear2db(rA(f));
Atable(f) = rdtable(int(SRmax/2)+1,A(time),int(f:max(20):int(min(SRmax/4))));


chooseResonBP(stable,fc,Q,gain) = filter
with {
  filter = _<:select2(stable,resonbp(fc,Q,gain),resonbpStable(fc,Q,gain));
};
// stable resonbp = 2nd-order bandpass
resonbpStable(fc,Q,gain) = tf2snp(b2,b1,b0,a1,a0,wc)
with {
     wc = 2*PI*fc;
     a1 = 2/Q;
     a0 = 1;
     b2 = 0;
     b1 = gain;
     b0 = 0;
};

// WIP stable highpass
// highpass(N,fc) = lowpass0_highpass1(1,N,fc);
// lowpass0_highpass1(s,N,fc) = lphpr(s,N,N,fc)
// with {
//   lphpr(s,0,N,fc) = _;
//   lphpr(s,1,N,fc) = tf1s(s,1-s,1,2*PI*fc);
//   lphpr(s,O,N,fc) = lphpr(s,(O-2),N,fc) : tf2s(s,0,1-s,a1s,1,w1) with {
//     parity = N % 2;
//     S = (O-parity)/2; // current section number
//     a1s = -2*cos(-PI + (1-parity)*PI/(2*N) + (S-1+parity)*PI/N);
//     w1 = 2*PI*fc;
//   };
// };
// n needs to be even
highpassStable(N,fc) = lphpr(N,N,fc)
with {
  lphpr(0,N,fc) = _;
  lphpr(1,N,fc) = _;
  lphpr(O,N,fc) = lphpr((O-2),N,fc) : tf2snp(1,0,0,a1s,1,w1) with {
    parity = N % 2;
    S = (O-parity)/2; // current section number
    a1s = -2*cos(-PI + (1-parity)*PI/(2*N) + (S-1+parity)*PI/N);
    w1 = 2*PI*fc;
  };
};


KalmanFilter(errorMeasurement,initialMeasurement,initialError,measurement) = KalmanFilterCalc(measurement)~(_,_):(_,!) with {
  KalmanFilterCalc(measurement,prevEstimate,prevErrorEstimate) =
    estimate(prevErrorEstimateT,prevEstimateT,measurement),
    errorEstimate(prevErrorEstimateT) with {
      KalmanGain(prevErrorEstimateT) = prevErrorEstimateT/(prevErrorEstimateT + errorMeasurement);
      estimate(prevErrorEstimateT,prevEstimateT,measurement) = prevEstimateT +(KalmanGain( prevErrorEstimateT)*( measurement - prevEstimateT));
      errorEstimate(prevErrorEstimateT) = (1- KalmanGain(prevErrorEstimateT))*prevErrorEstimateT;
      time = 1+_~_;
      prevEstimateT = select2((time==1),prevEstimate,initialMeasurement);
      prevErrorEstimateT = select2((time==1),prevErrorEstimate,initialError);
  };
};

gainedSmoother(gain,initialMeasurement,measurement) = gainedSmootherCalc(measurement)~(_) with {
  gainedSmootherCalc(measurement,prevEstimate) =prevEstimate +(gain*( measurement - prevEstimate));
};





// crossfade between multiple inputs (just the gain)
xfadeSelector(sel,nr) =
((sel<=nr)*((sel-nr)+1):max(0)) + ((sel>nr)*((nr-sel)+1):max(0));


// select at run-time how many instances of 'expression' you want in series.
// expression can have any number of inputs, but obviously must have the same number of outputs
// i; the selector, can be a float, so clickless fades are possible.
// N is the maximum number of expressions
varSeq(i,N, expression) =
  sequential(N,expression)
  :select
with {
  inNr = inputs(expression);
  seqPart(0,expression) = bus(inNr);
  seqPart(1,expression) = bus(inNr)<:(bus(inNr),expression);
  seqPart(N,expression) = bus(inNr*(N-1)) , seqPart(1,expression);
  sequential(N,expression) = seq(i, N+1, seqPart(i,expression) );
  busSelect(i,j) = par(k, inNr, _*xfadeSelector(i,j));
  select = par(j,N+1,busSelect(i,j) ):>bus(inNr);
};



autoSat(x) = x:min(1):max(-1)<:2.0*_ * (1.0-abs(_)*0.5);

// postProc(audio,freq,nrOutChan,ambisonicsOn,enableAutosat,volume,width)
// no ambisonics
postProc(audio,freq,nrOutChan,0,enableAutosat,volume,width) =
  ( par(i, nrOutChan, _*(volume:dezip)):WidePanner(width,nrOutChan):par(i,nrOutChan,dcblocker <:select2(enableAutosat,_,autoSat)) );
// ambisonic
postProc(audio,freq,nrOutChan,1,enableAutosat,volume,width) =
           wider(ambisonicsOrder,width) :rotate(ambisonicsOrder, rotation) :optimInPhase(ambisonicsOrder)
           <:((decoderStereo(ambisonicsOrder):par(i,2,(_*volume):dcblocker<: select2(enableAutosat,_,autoSat))), bus(2*ambisonicsOrder+1));

//to make it stereo
//todo: implement http://music.columbia.edu/pipermail/music-dsp/2012-February/070328.html
/*WidePanner(w,L,R) = (((1+w)*L + (1-w)*R)/2) , (((1+w)*R + (1-w)*L)/2);*/
WidePanner(w,2) = bus2<:(((1+w)*L + (1-w)*R)/2) , (((1+w)*R + (1-w)*L)/2)
with {
  L = selector(0,2);
  R = selector(1,2);
};
// for mutichannel, bypass the widepanner.
WidePanner(w,nr) = bus(nr);
voice(audio,freq) = qompander(audio:highpass(3,freq*0.75),factor,threshold,attack,release);

//is actually dual mono. on purpose; to try and keep the image in the center.
//todo: make this stereo, and find a better way for  KP-FX to stay centered
oldstereoLimiter(pitch)=
  (dcblocker*0.5:compressor_mono(100,-12,decay*0.5,decay)),
  (dcblocker*0.5:compressor_mono(100,-12,decay*0.5,decay)):
  (compressor_mono(100,-6,0.001,decay*0.5)),
  (compressor_mono(100,-6,0.001,decay*0.5))
  with {
    decay                                = (1/pitch);
    same(x,time)                         = (x@time) == x;
    intervalTester(x,nrSamples,interval) = (prod(i,nrSamples,same(x,i*interval+1)));
    blockNoise                           = par(i,2,(intervalTester(pitch,2,265)*-1+1:smooth(0.999))*_);
    };

monoLimiter(pitch)=
  (dcblocker:compressor_mono(100,-6,decay*0.5,decay)):
  (compressor_mono(100,-3,0,decay*0.5))
  with {
    decay                                = (1/pitch);
    same(x,time)                         = (x@time) == x;
    intervalTester(x,nrSamples,interval) = (prod(i,nrSamples,same(x,i*interval+1)));
    blockNoise                           = par(i,2,(intervalTester(pitch,2,265)*-1+1:smooth(0.999))*_);
    };

stereoLimiter(pitch) =monoLimiter(pitch),monoLimiter(pitch);
