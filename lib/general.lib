//-----------------------------------------------
// master index, all slave oscilators 'clock' to this.
//-----------------------------------------------
// simple sawtooth waveform oscillator between 0 and 1
masterIndex(freq)= lf_sawpos(freq/4); // lowest possible pitch, as we can only shift up, using wrap
fund(freq,oct)= (4 * oct * masterIndex(freq)) - floor(4 * oct * masterIndex(freq)); //choose octaves
fundPhase(freq,oct, phase)= (4 * oct * masterIndex(freq)) - floor(4 * oct * masterIndex(freq)); //choose octaves and set phase

//-----------------------------------------------
// Some general functions
//-----------------------------------------------
// dezipper
dezip(x) = x:smooth(0.999);
// minimum of n values
minOfN(1) = _;
minOfN(2) = min;
minOfN(n) = (minOfN(n-1),_):min;
// maximum of n values
maxOfN(1) = _;
maxOfN(2) = max;
maxOfN(n) = (maxOfN(n-1),_):max;
// sum of n values
sumOfN(1) = _;
sumOfN(2) = +;
sumOfN(n) = (sumOfN(n-1),_):+;
// cheaper than actual dB calculations:
volScale=_:pow(2):smooth(0.999);
envelop                 = abs : max ~ -(1.0/SR) : max(db2linear(-70)) : linear2db;
VuMeter                 = par(i,2,_<:(_, (envelop :(OSCgroup(MeterGroup(hbargraph("[4][unit:dB][tooltip: output level in dB]", -70, +6))))):attach));

octaveMultiplier	=
    _<:
    (
        (_==-2) * 0.25,
        (_==-1) * 0.5,
        (_==0),
        (_==1) * 2,
        (_==2) * 4
    ):>_;

      // make a log array of values, from bottom to top
LogArray(bottom,top,nrElements) =     par(i,nrElements,   pow((pow((top/bottom),1/(nrElements-1))),i)*bottom);

VocoderFreqsChooser(bottom,mid,band,top,0) = VocoderFreqs(bottom,top);
VocoderFreqsChooser(bottom,mid,band,top,1) = VocoderFreqsParametricMid(bottom,mid,band,top);


VocoderFreqs(bottom,top) = LogArray(bottom,top,nrBands);

VocoderFreqsParametricMid(bottom,mid,band,top) =
  (
    (
    (LogArray(midVal(1),top,nrBands):par(i,nrBands,_*(xfadeSelector(band,1))))
    ,((bottom,LogArray(midVal(2),top,nrBands-1)):par(i,nrBands,_*(xfadeSelector(band,2))))
    )
    ,par(j,nrBands-4,
        (
            (LogArray(bottom,midVal(midBand),midBand):(bus(midBand-1),!))
            ,LogArray(midVal(midBand),top,nrBands-midBand+1)
        ):par(i,nrBands,_*(xfadeSelector(band,midBand)))with {midBand=j+3;}
    )
    ,
    (
      ((LogArray(bottom,midVal(nrBands-1),nrBands-1),top):par(i,nrBands,_*(xfadeSelector(band,nrBands-1))))
      ,(LogArray(bottom,midVal(nrBands),nrBands):par(i,nrBands,_*(xfadeSelector(band,nrBands))))
    )
  )
  :>bus(nrBands)
  with {
  midVal(band)=
  ((mid>0)*((pow(((top/origMid(band))),mid)*origMid(band))))
  + ((mid<=0)*((pow(((bottom/origMid(band))),abs(mid))*origMid(band))));

  /*((mid>0)*(((mid*(top-origMid(band)))+origMid(band))))*/
  /*+ ((mid<=0)*(((mid)*(origMid(band)-bottom))+origMid(band)));*/
  origMid(band) = (VocoderFreqs(bottom,top):selector(band-1,nrBands)):>_;
  };


      // make a lin array of values, from bottom to top
      //VocoderLinArray(bottom,top) =     par(i,nrBands,   ((top-bottom)*(i/(nrBands-1)))+bottom);

LinArray(bottom,top,0) =   0:! ;
LinArray(bottom,top,nrElements) =     par(i,nrElements,   ((top-bottom)*(i/(nrElements-1)))+bottom);

VocoderLinArrayChooser(bottom,mid,band,top,0) = VocoderLinArray(bottom,top);
VocoderLinArrayChooser(bottom,mid,band,top,1) = VocoderLinArrayParametricMid(bottom,mid,band,top);

VocoderLinArray(bottom,top) =     LinArray(bottom,top,nrBands);
      // doesn't compile:
/*VocoderLinArrayParametricMid(bottom,mid,band,top) = ArrayPart(floor(band+1)):par(i,nrBands,_*(xfadeSelector(band,floor(band+1))))*/
           /*with {*/
/*ArrayPart(1)         = LinArray(mid,top,nrBands);*/
/*ArrayPart(2)         = bottom,LinArray(mid,top,nrBands-1);*/
/*ArrayPart(midBand)         =*/
  /*(LinArray(bottom,mid,midBand):(bus(midBand-1),!))*/
  /*,LinArray(mid,top,nrBands-midBand+1);*/
           /*};*/
/*ArrayPart(nrBands-1) = LinArray(bottom,mid,nrBands-1),top;*/
/*ArrayPart(nrBands)   = LinArray(bottom,mid,nrBands);*/

VocoderLinArrayParametricMid(bottom,mid,band,top) =
(
  (
  (LinArray(mid,top,nrBands):par(i,nrBands,_*(xfadeSelector(band,1))))
  ,((bottom,LinArray(mid,top,nrBands-1)):par(i,nrBands,_*(xfadeSelector(band,2))))
  )
  ,par(j,nrBands-4,
      (
         (LinArray(bottom,mid,midBand):(bus(midBand-1),!))
         ,LinArray(mid,top,nrBands-midBand+1)
      ):par(i,nrBands,_*(xfadeSelector(band,midBand)))with {midBand=j+3;}
  )
  ,
  (
    ((LinArray(bottom,mid,nrBands-1),top):par(i,nrBands,_*(xfadeSelector(band,nrBands-1))))
    ,(LinArray(bottom,mid,nrBands):par(i,nrBands,_*(xfadeSelector(band,nrBands))))
  )
)
:>bus(nrBands);

bt=hslider("[0]bottom", 0, 0, 1, 0.001);
md=hslider("[1]mid", 0, 0, 1, 0.001);
bd=hslider("[2]band", nrBands/2, 1, nrBands, 0.001);
tp=hslider("[3]top", 0, 0, 1, 0.001);

  GRmeter_group(x)  = vgroup("[3] GR [tooltip: gain reduction in dB]", x);
    meter(nr)           = GRmeter_group(  _<:(_,(_:min(1):max(0):( (hbargraph("%nr", 0, 1))))):attach);

/*process = VocoderLinArrayParametricMid(bt,md,bd,tp):par(i,nrBands,meter(i));*/

//normal mixer without outputRouting
vocoderMixer(0,0) = bus(nrBands):>bus(nrOutChan);

//normal mixer with outputRouting
vocoderMixer(0,1) =bus(nrBands)<:(
                (par(i,nrOutChan, bus(nrBands/nrOutChan):>((xfadeSelector(outputRouting,0):dezip) *_)))
               ,(bus(nrBands):>(par(i,nrOutChan, (xfadeSelector(outputRouting,1):dezip)*_)))
               ,(par(i,nrOutChan, bus(nrBands/nrOutChan):>((xfadeSelector(outputRouting,2):dezip)) *_):butterfly(nrOutChan))
               ,(interleave(nrBands/nrOutChan,nrOutChan):par(i, nrOutChan,(bus(nrBands/nrOutChan):>_*((xfadeSelector(outputRouting,3):dezip)))))
               ,(bus(nrBands):>butterfly(nrOutChan):par(i,nrOutChan,((xfadeSelector(outputRouting,4):dezip)) *_):cross(nrOutChan))
               ,(interleave(nrBands/nrOutChan,nrOutChan):par(i, nrOutChan,(butterfly(nrBands/nrOutChan):>_*((xfadeSelector(outputRouting,5):dezip)))))
               ,(butterfly(nrBands):>(par(i,nrOutChan,((xfadeSelector(outputRouting,6):dezip) *_))))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrOutChan);

// Ambisonics mixer.
vocoderMixer(1, outputRoutingEnabled)  = routing(outputRoutingEnabled):((angles,bus(nrBands)): interleave(nrBands,2)) : par(i,nrBands,myMap):>bus((ambisonicsOrder*2)+1)
with {
  myMap(a) = _<:encoder(ambisonicsOrder, _, a);
  angles = par(i,nrBands/2,   ((angleTop-angleBottom)*(i/(nrBands/2)))+angleBottom)<:(bus(nrBands/2),par(i,nrBands/2,_*-1)):interleave(nrBands/2,2);
  routing(0) = bus(nrBands);
  routing(1) =bus(nrBands)<:(
               (bus(nrBands):(par(i,nrBands,(xfadeSelector(outputRouting,0):dezip) *_)))
               ,(interleave(nrBands/nrOutChan,nrOutChan):(par(i,nrBands,(xfadeSelector(outputRouting,1):dezip) *_)))
               ,(butterfly(nrBands):(par(i,nrBands,(xfadeSelector(outputRouting,2):dezip) *_)))
               ,(butterfly(nrBands):interleave(nrBands/nrOutChan,nrOutChan):(par(i,nrBands,(xfadeSelector(outputRouting,3):dezip) *_)))
               /*,(hademar:>par(i,nrOutChan, (outputRouting==2) *_))*/
             ):>bus(nrBands);
};
// crossfade between multiple inputs (just the gain)
xfadeSelector(sel,nr) =
(((sel<=nr)*((sel-nr)+1):max(0))
+ ((sel>nr)*((nr-sel)+1):max(0))
);

autoSat(x) = x:min(1):max(-1)<:2.0*_ * (1.0-abs(_)*0.5);

postProc(nrOutChan,0,volume,width) = par(i, nrOutChan, _*volume):WidePanner(width,nrOutChan):par(i,nrOutChan,dcblocker:autoSat);

postProc(nrOutChan,1,volume,width) =
           wider(ambisonicsOrder,width) :rotate(ambisonicsOrder, rotation) :optimInPhase(ambisonicsOrder)
           <:((decoderStereo(ambisonicsOrder):par(i,2,(_*volume):dcblocker: autoSat)), bus(2*ambisonicsOrder+1));
//to make it stereo
//todo: implement http://music.columbia.edu/pipermail/music-dsp/2012-February/070328.html
/*WidePanner(w,L,R) = (((1+w)*L + (1-w)*R)/2) , (((1+w)*R + (1-w)*L)/2);*/
WidePanner(w,2) = bus2<:(((1+w)*L + (1-w)*R)/2) , (((1+w)*R + (1-w)*L)/2)
with {
  L = selector(0,2);
  R = selector(1,2);
};
// for mutichannel, bypass the widepanner.
WidePanner(w,nr) = bus(nr);
voice(audio) = qompander(audio:highpass(3,PitchTracker(audio,enablePitchTracker)*0.75),factor,threshold,attack,release);

//is actually dual mono. on purpose; to try and keep the image in the center.
//todo: make this stereo, and find a better way for  KP-FX to stay centered
oldstereoLimiter(pitch)=
  (dcblocker*0.5:compressor_mono(100,-12,decay*0.5,decay)),
  (dcblocker*0.5:compressor_mono(100,-12,decay*0.5,decay)):
  (compressor_mono(100,-6,0.001,decay*0.5)),
  (compressor_mono(100,-6,0.001,decay*0.5))
  with {
    decay                                = (1/pitch);
    same(x,time)                         = (x@time) == x;
    intervalTester(x,nrSamples,interval) = (prod(i,nrSamples,same(x,i*interval+1)));
    blockNoise                           = par(i,2,(intervalTester(pitch,2,265)*-1+1:smooth(0.999))*_);
    };

monoLimiter(pitch)=
  (dcblocker:compressor_mono(100,-6,decay*0.5,decay)):
  (compressor_mono(100,-3,0,decay*0.5))
  with {
    decay                                = (1/pitch);
    same(x,time)                         = (x@time) == x;
    intervalTester(x,nrSamples,interval) = (prod(i,nrSamples,same(x,i*interval+1)));
    blockNoise                           = par(i,2,(intervalTester(pitch,2,265)*-1+1:smooth(0.999))*_);
    };

stereoLimiter(pitch) =monoLimiter(pitch),monoLimiter(pitch);
